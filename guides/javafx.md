# JavaFX и с чем его едят

## Кратко о графических фреймворках Java

Подробное сравнение разных фреймворков (не только Swing и JavaFX): https://stackoverflow.com/questions/7358775/java-gui-frameworks-what-to-choose-swing-swt-awt-swingx-jgoodies-javafx

Сравнение Swing и JavaFX: https://www.educba.com/java-swing-vs-java-fx/

#### Личное мнение

Когда я выбирал, меня привлек JavaFX возможностью писать UI
не на Java, которая для этого не очень-то подходит,
а на подобии HTML - FXML, то есть на декларативном языке,
который для UI подходит больше всего.
У JavaFX также есть возможность стилизации с помощью подобия CSS.

Не могу сказать, что JavaFX - это лучший выбор, но точно не худший.
И тем, кто не может определиться, что учить, я бы рекомендовал JavaFX,
а Swing можно изучить при необходимости
(на базовом уровне он, возможно, даже проще)

## Информация для юзающих Java 9+ (надеюсь, вас большинство)

JavaFX входил в JVM до версии 1.8, но, начиная с Java 9,
был удален оттуда, поэтому для запуска приложений с использованием
JavaFX на JVM 9+ необходимо включать модули JavaFX в собираемый JAR
(или присоединять к JAR-нику, что сложнее, потому что надо разбираться
в Java modules, т.е. Project Jigsaw, который был добавлен как раз в 9ой версии). JDK, поставляемый вместе с IntelliJ IDEA,
до недавнего времени включал в себя JavaFX, так что может быть такое, что при разработке
все работает, а при запуске собранного JAR на другой JVM не работает ничего.
Во избежание такого рекомендую сразу добавлять зависимости в Maven/Gradle.
В документации к OpenJFX (JavaFX как отдельная библиотека) описано,
какие зависимости нужно прописать в pom.xml/build.gradle для cross-platform JAR (см. Non-modular application): https://openjfx.io/openjfx-docs/#modular

## Scene Builder

Для JavaFX есть прекрасный графический редактор UI - Scene Builder.
Для многих проектов его возможностей хватает,
чтобы создать разметку, не написав не строчки FXML кода.
Не помню почему, но я использовал Gluon Scene Builder (возможно, другого сейчас просто и нет): [ссылка для скачивания](https://gluonhq.com/products/scene-builder/).

IDEA прекрасно интегрируется с Scene Builder, нужно только указать путь к нему в настройках IDE (Settings → Languages & Frameworks → JavaFX → Path to SceneBuilder)

## Примерный план изучения

### 1. Создание первого приложения
  Отличный гайд на Хабре с использованием FXML: https://habr.com/ru/post/474982/

  Точка входа приложения с запуском JavaFX Stage (т.е. окна):
  ```java
public class FXApp extends Application {
  public static void main(String[] args) {
    launch(args);
  }

  @Override
  public void start(Stage primaryStage) {
    URL url = (new File("/.../fxml_name.fxml")).toURI().toURL();
    FXMLLoader loader = new FXMLLoader(url);
    Pane pane = (Pane) loader.load();
    primaryStage.setTitle("SAP Windows App");
    primaryStage.setScene(new Scene(pane));

    primaryStage.show();
  }
}
  ```

### 2. Создание первого проекта
Не важно, делаете ли вы проект с нами или нет,
написать небольшой проект на JavaFX стоит, т.к. это
помогает начать различать составляющие MVC (Model View Controller) -
одного из самых популярных паттернов проектирования,
изначально придуманного как раз для десктопных приложений,
а потом адаптированного под Web, где активно применяется
сейчас.

* Model - сама бизнес-логика. Она состоит из моделей
и сервисов.
Модели - POJO (Plain old data object, т.е. простые Java-объекты), цель которых - хранить данные и передавать их между разными частями программы.
Сервисы - чаще всего синглтоны, цель которых -
осуществлять бизнес-логику, т.е. основные действия
программы (расчеты, изменения данных и т.п.)
* View - в данном случае, это FXML код.
При создании UI с помощью кода, а не через FXML,
View будет считаться классы, ответственные за отображение
поступающих к ним данным (и не отвественные ни за что другое)
* Controller - это прослойка между UI и бизнес-логикой.
Контроллеры выполняют вызов методов соответствующего сервиса, используя полученные из UI (View) данные,
введенные пользователем

### 3. Создание приложения с несколькими окнами и/или сценами
И вот тут мы упираемся в одну из главных проблем JavaFX -
сложность передачи данных между разными окнами.
Когда в моем рабочем проекте потребовался такой функционал, я сделал костыль - добавил callback (т.е. метод, который передавался как аргумент), который необходимо было вызывать при изменении введенных данных.
В другом проекте все было более красиво, но тоже в какой-то мере костыль -
был добавлен абстрактный класс Controller, от которого
необходимо было наследовать все контроллеры.
Этот класс также мог загружать другие Scenes,
а также хранил данные, переданные в него предыдущим контроллером, в виде `Map<String, Object>`. [Этот код](https://github.com/kuzznya/WindowsSAPJavaClientApp/blob/master/src/main/java/kzn/view_controllers/Controller.java) я писал в начале своего изучения Java, так что тут не стоит смотреть на кодстайл и вообще на качество кода, но общая идея будет понятна.

Одна из идей наших последующих проектов как раз и заключается в том, чтобы создать удобную библиотеку
для роутинга, передачи данных между контроллерами и создания новых окон (как диалоговых, так и отдельных). Но этим мы если и займемся, то попозже.

### 4. Использование JavaFX при необходимости и уход от него

Создание десктопных приложений - достаточно приятный процесс,
но необходимо помнить, что практически никто не применяет Java для этих целей.
Поэтому стоит применять JavaFX и вообще графические фреймворки для Java для того, чтобы быстро набросать приложение, но слишком много времени тратить на изучение JavaFX/Swing/прочих тоже не стоит.
